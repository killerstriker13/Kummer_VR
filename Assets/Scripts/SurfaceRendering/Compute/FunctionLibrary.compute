#pragma kernel GenerateNoise
#pragma kernel GenerateNoisePlane

#include "Includes\FastNoiseLite.compute"
#include "Includes\MetricsCompute.compute"

RWStructuredBuffer<float> _Weights;

uint _IsPlane;
uint _Function;
float _Size;
float _Scale;
float _Amplitude;
float _Frequency;
float _OtherSize;
float3 _Offset;
float3 _PlaneRight;
float3 _PlaneForward;
uint _Orientation;
float _MuSquaredActual;



float valCalc(float3 pos){
    //float _MuSquaredActual = __MuSquaredActualActual;
    float w = 1.0f;
    float val = 0;
    float x = pos.x;
    float y = pos.y;
    float z = pos.z;


    switch (_Function)
    {
        case 0:
            float p = w - z - sqrt(2) * x;
            float q = w - z + sqrt(2) * x;
            float r = w + z + sqrt(2) * y;
            float s = w + z - sqrt(2) * y;

            float lambda = (3 *  _MuSquaredActual - 1) / (3 - _MuSquaredActual);
            //float equation = 
            val = ((x * x) + (y * y) + (z * z) - ( _MuSquaredActual * (w * w))) * ((x * x) + (y * y) + (z * z) - ( _MuSquaredActual * (w * w))) - (lambda * (p * q * r * s));
            //x * x + y * y + z * z - 1;
        //           Mathf.Pow(Mathf.Pow(x, 2) + Mathf.Pow(y, 2) + Mathf.Pow(z, 2) - (muSquared * Mathf.Pow(w, 2)), 2)
            //if (equation < 0.001f)
            //{
            
            //}
            break;
        
    }

    return val;
}


float3 ExchangeAxis(float3 vec){
    float3 newVec = vec;
    switch(_Orientation){        
        case 0:
            newVec.z = vec.y;
            newVec.y = vec.z;
            break;
        case 1:
            newVec.y = vec.x;
            newVec.z = vec.y;
            newVec.x = vec.z;
            break;
        case 2:
            newVec.z = vec.x;
            newVec.x = vec.z;
            break;
    }
    return newVec;
}



[numthreads(numThreads, numThreads, numThreads)]
void GenerateNoise(uint3 id : SV_DispatchThreadID)
{
    
    float3 pos = ((id - float3(1, 1, 1) * _ChunkSize / 2.0f)*_OtherSize + _Offset) / _Scale;
    _Weights[indexFromCoord(id.x, id.y, id.z)] = 0;
    pos = ExchangeAxis(pos);

    float val = valCalc(pos);

    if (val <= _Amplitude)
    {
        float sigmoid = 1 / (1 + exp(val));
        _Weights[indexFromCoord(id.x, id.y, id.z)] = sigmoid;        
    }
}

[numthreads(numThreads, numThreads, 1)]
void GenerateNoisePlane(uint3 id : SV_DispatchThreadID)
{

    float3 pos = ((id.x - _ChunkSize / 2.0f) * _PlaneRight + (id.y - _ChunkSize / 2.0f) * _PlaneForward + _Offset) / _Scale;
    _Weights[indexFromCoord(id.x, id.y, 0)] = 0;
    pos = ExchangeAxis(pos);
    

    float val = valCalc(pos);

    if (val <= _Amplitude)
    {
        float sigmoid = 1 / (1 + exp(val));
        _Weights[indexFromCoord(id.x, id.y, 0)] = sigmoid;
        
    }
}